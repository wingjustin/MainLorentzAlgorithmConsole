# MainLorentzAlgorithmConsole

<h3>Main-Lorentz Algorithm</h3>

<p>

Main-Lorentz 算法以四元组 (cntr, l, k_1, k_2) 的形式给出所有重串。
<br><br>先把整個字串割開一半分成左右兩邊, 設cntr為當前指針並移動逐一處理
<br><br><div>設cntr為重複字串中左原字串或右原字串的中心, 2*l為重複字串總長度, l為原串(左或右)長度
<br>,稱cntr在左邊找到的重串為左偏重串, 在右邊找到的重串為右偏重串</div>
<br>
<ul>
<li><div>當cntr在左邊時, cntr為左原串的中心, 分割線右邊最近字符為右原串的中心</div></li>
<li><ul>
<li>, k_1為由分割線左邊最近字符開始向左的子字串跟由cntr的前一個字符開始向左的子字串的相同字符數目, 這裡用反轉左子字串z function 取得每個字符的計算數目
<br>, 當重串成立, 其可以轉化成數個由原串的首字符到原串中心的前一個字符的長度, 將每個轉化結果設成l1</li>
<li>, k_2為由cntr開始向右的子字串跟由分割線右邊最近字符開始向右的子字串的相同字符數目, 這裡用右子字串合併左子字串z function 取得每個字符的計算數目
<br>, 當重串成立, 其可以轉化成數個由原串中心到原串的尾字符的長度, 將每個轉化結果設成l2</li>
</ul></li>
<li>l = l1 + l2 = 左子串長度 - cntr</li>
<li>當k_1 + k_2 >= l, 重串成立</li>
<li>轉化過程中如果l1為0時該重串的左原串完全在左邊,右原串完全在右邊,如果cntr在右邊已經取得這種交叉重串, 這裡就別取,會取得重複結果</li>
<br><br>
<li><div>當cntr在右邊時, cntr為右原串的中心, 分割線左邊最近字符為左原串的中心</div></li>
<li><ul>
<li>, k_1為由分割線右邊最近字符開始向右的子字串跟由cntr的後一個字符開始向右的子字串的相同字符數目, 這裡用右子字串z function 取得每個字符的計算數目
<br>, 當重串成立, 其可以轉化成數個由原串中心的後一個字符到原串的尾字符的長度, 將每個轉化結果設成l2</li>
<li>, k_2為由cntr開始向左的子字串跟由分割線左邊最近字符開始向左的子字串的相同字符數目, 這裡用反轉右子字串合併左子字串z function 取得每個字符的計算數目
<br>, 當重串成立, 其可以轉化成數個由原串的首字符到原串中心的長度, 將每個轉化結果設成l1</li>
</ul></li>
<li>l = l1 + l2 = cntr - 左子串長度 + 1</li>
<li>當k_1 + k_2 >= l, 重串成立</li>
<li>轉化過程中如果l2為0時該重串的左原串完全在左邊,右原串完全在右邊,如果cntr在左邊已經取得這種交叉重串, 這裡就別取,會取得重複結果</li>
</ul>

<div>References : </div>
<ul>
<li>https://oi-wiki.org/string/main-lorentz/</li>
</ul>
</p>
